create table "public"."banner" (
    "id" bigint generated by default as identity not null,
    "banner_exist" boolean not null default false,
    "text" text default ''::text
);


create table "public"."items" (
    "id" bigint generated by default as identity not null,
    "dateAdded" timestamp with time zone not null default now(),
    "dateOnHold" timestamp with time zone,
    "imageURL" text not null,
    "tags" text[] not null,
    "title" text not null,
    "holder_id" uuid
);


alter table "public"."items" enable row level security;

create table "public"."store_status" (
    "id" bigint generated by default as identity not null,
    "is_closed" boolean not null default false
);


create table "public"."users" (
    "id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "email" text not null default ''::text,
    "name" text not null,
    "holds" integer not null default 0,
    "is_admin" boolean not null default false
);


CREATE UNIQUE INDEX banner_pkey ON public.banner USING btree (id);

CREATE UNIQUE INDEX items_pkey ON public.items USING btree (id);

CREATE UNIQUE INDEX "store_status_pkey" ON public."store_status" USING btree (id);

CREATE UNIQUE INDEX users_email_key ON public.users USING btree (email);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id);

alter table "public"."banner" add constraint "banner_pkey" PRIMARY KEY using index "banner_pkey";

alter table "public"."items" add constraint "items_pkey" PRIMARY KEY using index "items_pkey";

alter table "public"."store_status" add constraint "store_status_pkey" PRIMARY KEY using index "store_status_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."items" add constraint "items_holder_id_fkey" FOREIGN KEY (holder_id) REFERENCES users(id) not valid;

alter table "public"."items" validate constraint "items_holder_id_fkey";

alter table "public"."users" add constraint "users_email_key" UNIQUE using index "users_email_key";

alter table "public"."users" add constraint "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) not valid;

alter table "public"."users" validate constraint "users_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_user_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin
  insert into public.users (id, email, name)
  values (new.id, new.email, new.raw_user_meta_data->>'full_name');
  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION check_admin(user_id uuid)
    returns boolean AS
    $$
    select is_admin from public.users
    where id = user_id
    $$ stable language sql security definer;

create policy "Enable read access for all users"
on "public"."items"
as permissive
for select
to public
using (true);

CREATE OR REPLACE FUNCTION public.check_admin(user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
select is_admin from public.users
where id = user_id
    $function$
;

create policy "Admins can update banner"
on "public"."banner"
as permissive
for update
to public
using (check_admin(auth.uid()));


create policy "Any user can view banner"
on "public"."banner"
as permissive
for select
to public
using (true);


create policy "Admin can insert items "
on "public"."items"
as permissive
for insert
to public
with check (check_admin(auth.uid()));


create policy "Admin users can update store status"
on "public"."store_status"
as permissive
for update
to public
using (check_admin(auth.uid()));


create policy "Any user can view store status"
on "public"."store_status"
as permissive
for select
to public
using (true);


create policy "Admins can update users"
on "public"."users"
as permissive
for update
to public
using (check_admin(auth.uid()));


create policy "Admins can view users"
on "public"."users"
as permissive
for select
to public
using (check_admin(auth.uid()));

create policy "Admins can upload images 1nq2cb_0"
on "storage"."objects"
as permissive
for insert
to public
with check (((bucket_id = 'image'::text) AND check_admin(auth.uid())));

alter table "public"."banner" enable row level security;

alter table "public"."store_status" enable row level security;

alter table "public"."users" enable row level security;

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.select_avaliable_rows()
 RETURNS record
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin
  return (SELECT * FROM public.items WHERE holder_id IS null);
end;$function$
;


create policy "Admins can upload images 1ffg0oo_0"
on "storage"."objects"
as permissive
for insert
to public
with check (((bucket_id = 'images'::text) AND check_admin(auth.uid())));

/*CREATE TRIGGER AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION create_user_row();*/

drop policy "Admin can insert items " on "public"."items";

drop policy "Enable read access for all users" on "public"."items";

drop policy "Admins can update users" on "public"."users";

drop policy "Admins can view users" on "public"."users";

drop function if exists "public"."select_avaliable_rows"();

alter table "public"."users" alter column "is_admin" set default true;

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.reserve_item_user(item_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$declare currHolds int;
begin
  SELECT users.holds 
  INTO currHolds 
  from public.users 
  WHERE id = auth.uid();
  if currHolds >= 3 then 
    return (false);
  end if;
  currHolds = currHolds + 1;
  UPDATE public.users SET users.holds = currHolds WHERE id = auth.uid();
  UPDATE public.items SET items.holder_id = auth.uid() WHERE id = item_id; 
  return true;
end;$function$
;

create policy "Admins have full access to items"
on "public"."items"
as permissive
for all
to public
using (check_admin(auth.uid()));


create policy "All users can view items"
on "public"."items"
as permissive
for select
to public
using (true);


create policy "Auth users can update items unreserved or reversed by them"
on "public"."items"
as permissive
for update
to public
using (((holder_id IS NULL) OR (holder_id = auth.uid())));


create policy "Admin can update users"
on "public"."users"
as permissive
for update
to public
using (check_admin(auth.uid()));


create policy "Admins can select users"
on "public"."users"
as permissive
for select
to public
using (check_admin(auth.uid()));


create policy "Auth users can update themselves"
on "public"."users"
as permissive
for update
to authenticated
using ((id = auth.uid()));


create policy "Auth users can view themselves"
on "public"."users"
as permissive
for select
to authenticated
using ((auth.uid() = id));

